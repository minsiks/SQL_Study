# SQL 기본/~p103

## 2-2 SQL 활용

### DENSE_RANK

- 동일한 순위에 대해 동일한 순위를 부여한다.
- 동일한 순위는 하나의 건수로 계산한다.

### RANK

- 동일한 순위에 대해 동일한 순위를 부여한다.
- 동일한 순위를 하나의 건수로 계산하지 않는다.

### ROW_NUMBER

- 동일한 순위에 대해 고유한 순위를 부여한다.

### NTILE

- 그룹의로 나누는 함수

### PERCENT_RANK

- 값이 아닌, 순서를 대상으로, 파티션 내에서의 순서별 백분율을 조회함

### CUME_DIST

- 파티션 내 전체에서 현재 행의 값 이하인 레코드 건수에 대한 누적 백분율
- 누적 분포 상에 0~1값을 가짐

### FIRST_VALUE

- 파티션 내에서 가장 처음 나오는 값 반환
- MIN 과 동일한 결과

### LAST_VALUE

- 파티션 내에서 가장 마지막에 나오는 값 반환
- MAX와 동일한 결과

### LAG(컬럼명, 레코드위치차이값)

- 이전 행을 가져온다

### LEAD(컬럼명, 레코드위치차이값, null일경우 대체값)

- 다음(특정 위치의) 행을 가져온다.
- defualt는 1이다.

### UNBOUNDED PRECEDING

- 첫 번째 행

### UNBOUNDED FOLLOWING

- 마지막 행

### 테이블 파티션

- RANGE PARTITION
  - 값의 범위를 기준으로 파티션을 나눠 저장하는 방법
  - EX) 매출액이 50000이상인 레코드와 미만인 레코드를 별도로 저장
- LIST PARTITION
  - 특정 값을 기준으로 분할
  - EX) 특정 값이 100일 때와 250일 때 각각 다른 데이터파일에 저장
- HASH PARTITION
  - 데이터베이스 관리 시스템이 자체적으로 해시함수를 사용해 분할하고 관리하는 방식

### Optimaizer : SQL 실행계획을 수립하고, SQL을 실행하는 데이터베이스 관리 시스템의 소프트웨어

- 같은 SQL문이더라도 어떻게 실행하냐에 따라 성능이 달라진다(소요시간, 자원사용량 등)
  1. SQL문 작성
  2. Parsing : 문법검사, 구분 분석
  3. 옵티마이저 : 비용기반 / 규칙기반
  4. 실행계획 : PLAN_TABLE 저장
  5. SQL 실행

1. 비용기반 옵티마이저
   - 시스템 통계와 오브젝트 통계를 통해 해당 SQL문 실행에 대한 총 비용을 계산하고
   - 총 비용이 가장 적은 쪽으로 실행 계획을 수립한다.
2. 규칙기반 옵티마이저
   - 15가지 우선순위를 기준으로 실행계획을 수립한다. 

### INDEX Unique SCAN

- 인덱스 키값이 중복되지 않을 때 해당 키를 통해 탐색

### INDEX Range SCAN

- 특정 범위를 조회하는 WHERE문을 사용하여 해당 영역을 스캔

### INDEX Full SCAN

- 인덱스의 처음부터 끝까지 모두 스캔

> #### 옵티마이저 말문제
>
> - 인덱스는 내림차순으로 생성 및 정렬 됨
>
> - 규칙기반 옵티마이저에서 가장 높은 우선순위는 ROWID를 기반으로 스캔하는 것
>
> - 인덱스 범위 스캔은 단수의 결과 0건의 결과 복수 가능
>
> - 같은 SQL문이더라도 실행계획이 달라도 결과는 같다
>
> - 자주 변화하는 속성을 인덱스로 설정하는 것은 좋지 않다.
>
> - 보조인덱스는 중복 데이터 입력이 가능하다
>
> - 인덱스를 통한 스캔은 항상 전체 테이블 스캔보다 효율적이진 않다.
>
> - 비용 기반 옵티마이저는 인덱스 스캔이 유리할 수 도 있다.

### 옵티마이저 조인

- JOIN을 수행하는 과정에서 성능을 최적화하기 위해 사용

1. Nested Loop JOIN
   - 선행 테이블(외부 테이블, Driving Table)을 먼저 조회하고 연결 대상 데이터를 찾고, 그 다임 테이블(내부 테이블)을 연결함
   - 먼저 처리되는 데이터 양 - 선행 테이블(외부테이블, Driving Table)의 처리범위에 따라 처리량이 결정됨
   - 로우들간의 처리, 테이블 간의 처리 모두 순차적으로 일어난다.
   - 최적의 순서를 찾아주는 것이 중요하다.
   - RANDOM ACCESS 발생 (선행테이블에서 두 번째 테이블을 참조할 때 발생함)
   - 성능 지연을 줄이기 위해 RANDOM ACCESS가 적은 양이 발생하도록 해야함
   - 선행테이블 처리 범위가 많거나, 연결 테이블에서의 랜덤엑세스 범위가 많다면 SORT MERGE JOIN보다 불리해지는 경우가 있음
   - INDEX 가 필요, Unique Index 시 유리함
   - 온라인 트랜잭션 처리(OLTP)에 유용함

2. Sort Merge JOIN
   - 두 테이블을 각각 정렬하고, 완료되면 병합함
   - 정렬이 발생하기 때문에 데이터 양이 많을 경우 느려진다.
   - 정렬 대상 데이터 양이 많을 경우 임시 디스크를 사용하기 때문에, 성능이 저하됨
   - EQUI JOIN, non-EQUI JOIN 모두 가능함
3. HASH JOIN
   - 두 테이블 중 작은 테이블을 HASH 메모리에 로딩하고, 두 테이블의 조인 키를 사용하여 해시 테이블을 생성함
   - 두 테이블을 동시에 스캔함
   - 선행 테이블에는 작은 데이터가 먼저 와야함
   - 시스템 자원을 최대한 활용 가능하며, 너무 많이 사용할 우려도 있음
   - 대용량 처리에 빠른 처리 속도를 보임
   - EQUI JOIN에서만 가능함
   - INDEX를 사용하지 않음

### PX/SQL

- SQL 을 확장시켜 다양한 절차적 프로그래밍을 가능하게 한 언어
  - DML, IF, LOOP 문 등 다양한 절차적 언어를 사용
  - Block 구조로 되어있어서 기능별로 모듈화가 가능
  - 응용 프로그램의 성능을 향상시킴

- Procedure, User Defined Function, Trigger 객체 작성할 수 있다.
- 변수와 상수를 사용하여 문장에 대입할 수 있다.
- DECLARE, BEGIN ~END는 필수, EXCEPTION은 선택
- Procedure 내부에 작성된 절차적 코드는 PL/SQL엔진이 처리하고, 일반적 SQL 문장은 SQL 실행기가 처리한다.

### 분산 데이터베이스

